<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>RainClone ‚Äî Supercharged Demo</title>
<style>
  :root{
    --bg:#05060a; --card:#0f1316; --muted:#9aa0a6; --accent:#46d5ff; --accent-2:#7b61ff; --gold:#f5c156;
    --radius:12px; --glass: rgba(255,255,255,0.03);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono";
    --ui-scale: 1;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:
    radial-gradient(800px 400px at 10% 10%, rgba(70,213,255,0.03), transparent),
    linear-gradient(180deg,#05060a,#0b0b10); color:#e8f4f8;-webkit-font-smoothing:antialiased}
  .wrap{max-width:1300px;margin:18px auto;display:grid;grid-template-columns:260px 1fr 340px;gap:18px;align-items:start;padding:10px;transform:scale(var(--ui-scale));transform-origin:top left}
  header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02)}
  .logo{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:grid;place-items:center;font-weight:900}
  h1{margin:0;font-size:20px}
  .tag{color:var(--muted);font-size:13px}

  /* left */
  .left{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.02);height:calc(100vh - 150px);overflow:auto}
  .balance{font-weight:900;font-size:22px;color:var(--gold)}
  .game-list{display:flex;flex-direction:column;gap:10px;margin-top:12px}
  .game-btn{display:flex;gap:10px;align-items:center;padding:12px;border-radius:10px;background:transparent;border:1px solid transparent;cursor:pointer}
  .game-btn.active{background:linear-gradient(90deg, rgba(70,213,255,0.05), rgba(123,97,255,0.03));border-color:rgba(70,213,255,0.06);color:var(--accent);box-shadow:0 18px 34px rgba(0,0,0,0.55)}

  /* center */
  .center{min-height:680px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:12px}
  .home-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .card{padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);cursor:pointer;border:1px solid rgba(255,255,255,0.02);transition:transform .18s,box-shadow .18s}
  .card:hover{transform:translateY(-6px);box-shadow:0 20px 40px rgba(0,0,0,0.6)}

  /* focused */
  .focused{display:flex;gap:18px;align-items:flex-start}
  .main-game{flex:1;border-radius:12px;padding:16px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);min-height:520px;border:1px solid rgba(255,255,255,0.02)}
  .side{width:320px;display:flex;flex-direction:column;gap:12px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}

  /* crash chart (svg) */
  .crash-svg{width:100%;height:240px;background:linear-gradient(180deg, rgba(70,213,255,0.025), transparent);border-radius:8px;overflow:hidden}
  .crash-controls{display:flex;gap:8px;align-items:center;margin-top:12px}

  /* slots */
  .slots-row{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px}
  .reel{width:140px;height:180px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);display:grid;place-items:center;font-size:64px}
  .reel.spin{animation:spin 0.75s cubic-bezier(.2,.9,.1,1);}

  @keyframes spin{0%{transform:translateY(-20px) scaleY(1.02)}100%{transform:none}}

  /* mines */
  .mines-grid{display:grid;grid-template-columns:repeat(8,1fr);gap:8px}
  .mine-cell{height:64px;border-radius:10px;background:rgba(255,255,255,0.02);display:grid;place-items:center;cursor:pointer;color:var(--muted);font-weight:800}
  .mine-open{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));color:#fff}

  /* strategy simulator */
  .sim-controls{display:flex;gap:8px;align-items:center;margin-top:12px}

  /* right */
  .right{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.02);height:calc(100vh - 150px);overflow:auto}

  /* responsive */
  @media (max-width:1200px){
    .wrap{grid-template-columns:1fr; padding:12px}
    .right{display:none}
    .home-grid{grid-template-columns:repeat(2,1fr)}
    .mines-grid{grid-template-columns:repeat(6,1fr)}
  }
  /* small helpers */
  .muted{color:var(--muted)}
  .mono{font-family:var(--mono)}
  .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;background:linear-gradient(180deg,var(--accent),rgba(70,213,255,0.85));color:#022;font-weight:800}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
</style>
</head>
<body>
<header>
  <div style="display:flex;gap:12px;align-items:center">
    <div class="logo">RC</div>
    <div>
      <h1>RainClone ‚Äî Supercharged</h1>
      <div class="tag">Bigger UI ‚Ä¢ Smooth reels ‚Ä¢ SVG Crash chart ‚Ä¢ Strategy simulator</div>
    </div>
  </div>

  <div style="display:flex;gap:12px;align-items:center">
    <div style="text-align:right">
      <div class="muted">Profile</div>
      <div class="balance mono" id="topBalance">0 RC</div>
    </div>
    <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
      <div style="display:flex;gap:8px">
        <button class="btn ghost" id="exportBtn">Export</button>
        <button class="btn ghost" id="importBtn">Import</button>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <label class="muted">Save</label><input type="checkbox" id="persist" checked>
      </div>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- LEFT -->
  <aside class="left">
    <div>
      <div class="muted">Wallet</div>
      <div class="balance" id="wallet">0 RC</div>
      <div class="muted" style="font-size:13px;margin-top:6px">Demo balance (local)</div>
    </div>

    <div class="muted" style="margin-top:10px">Games</div>
    <div class="game-list" id="gameList">
      <button class="game-btn active" data-game="home">üè† Games Home</button>
      <button class="game-btn" data-game="crash">üìà Crash</button>
      <button class="game-btn" data-game="dice">üé≤ Dice</button>
      <button class="game-btn" data-game="mines">üí£ Mines</button>
      <button class="game-btn" data-game="slots">üé∞ Slots</button>
      <button class="game-btn" data-game="sim">üìä Strategy Simulator</button>
    </div>

    <div style="margin-top:16px">
      <div class="muted">Quick add</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="quickAdd" type="number" value="200" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit">
        <button class="btn ghost" id="addBtn">Add</button>
      </div>
    </div>

    <div style="margin-top:14px">
      <div class="muted">Session history</div>
      <div id="leftHistory" style="margin-top:8px;max-height:320px;overflow:auto;color:var(--muted);font-size:13px"></div>
    </div>
  </aside>

  <!-- CENTER -->
  <main class="center" id="center">
    <!-- HOME -->
    <div id="homeView">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <h2 style="margin:0">Games Home</h2>
          <div class="muted">Click a card or menu item to open a focused game that uses most of the screen.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="muted">UI scale:</div>
          <input id="uiScale" type="range" min="0.9" max="1.3" step="0.05" value="1">
        </div>
      </div>

      <div class="home-grid" style="margin-top:16px">
        <div class="card" data-open="crash"><h3>Crash</h3><p class="muted">Place a bet and cash out before it crashes. SVG history and zoom.</p></div>
        <div class="card" data-open="dice"><h3>Dice</h3><p class="muted">Simple roll game ‚Äî large faces and clear feedback.</p></div>
        <div class="card" data-open="mines"><h3>Mines</h3><p class="muted">Open tiles and avoid bombs ‚Äî cashout anytime.</p></div>
        <div class="card" data-open="slots"><h3>Slots</h3><p class="muted">Big physics-style reels with controlled stops.</p></div>
        <div class="card" data-open="sim"><h3>Strategy Simulator</h3><p class="muted">Backtest Martingale/Fixed strategies and view ROI charts.</p></div>
        <div class="card" data-open="crash"><h3>Practice Mode</h3><p class="muted">Lower risk for practicing cashouts and strategies.</p></div>
      </div>
    </div>

    <!-- FOCUSED area -->
    <div id="gameView" style="display:none" class="focused">
      <div class="main-game" id="mainGame"><!-- dynamic content --></div>

      <div class="side">
        <div class="panel">
          <div class="muted">Round</div>
          <div id="roundLabel" style="font-weight:900;margin-top:8px">‚Äî</div>
          <div id="roundSub" class="muted" style="margin-top:6px">Status & tips shown here.</div>
        </div>

        <div class="panel">
          <div class="muted">Quick Controls</div>
          <div style="margin-top:8px">
            <div class="muted">Bet</div>
            <input id="sideBet" type="number" value="100" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit">
            <div style="display:flex;gap:8px;margin-top:12px">
              <button class="btn" id="placeBtn">Place</button>
              <button class="btn ghost" id="cashBtn">Cashout</button>
            </div>
            <div class="muted" style="margin-top:10px">Shortcuts: Space = place ‚Ä¢ C = cashout</div>
          </div>
        </div>

        <div class="panel">
          <div class="muted">Analytics</div>
          <canvas id="analytics" width="300" height="140" style="width:100%;height:140px;margin-top:8px;background:rgba(255,255,255,0.01);border-radius:8px"></canvas>
          <div style="display:flex;justify-content:space-between;margin-top:8px"><div class="muted">Win rate</div><div id="winRate" style="font-weight:900">0%</div></div>
        </div>

        <div class="panel">
          <div class="muted">Achievements</div>
          <div id="achievements" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- RIGHT -->
  <aside class="right">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><div class="muted">Leaderboard</div><div id="leaders" style="margin-top:8px"></div></div>
        <div><div class="muted">Session</div><div id="stats" style="margin-top:8px">W:0 L:0</div></div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Provably-fair</div>
        <div style="display:flex;gap:8px">
          <button class="btn ghost" id="newSeed">New</button>
          <button class="btn" id="revealSeed">Reveal</button>
        </div>
      </div>
      <div id="provHash" class="muted mono" style="margin-top:8px">‚Äî</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="muted">Strategy Simulator</div>
      <div class="sim-controls" style="margin-top:8px">
        <select id="simMode"><option value="martingale">Martingale</option><option value="fixed">Fixed</option></select>
        <input id="simStart" type="number" value="50" style="width:80px;padding:8px;border-radius:8px">
        <input id="simRounds" type="number" value="100" style="width:80px;padding:8px;border-radius:8px">
        <button class="btn" id="runSim">Run</button>
      </div>
      <canvas id="simCanvas" width="320" height="140" style="width:100%;height:140px;margin-top:8px;background:rgba(255,255,255,0.01);border-radius:8px"></canvas>
    </div>

    <div class="panel" style="margin-top:12px">
      <div style="display:flex;gap:8px">
        <button class="btn ghost" id="exportFull">Export</button>
        <input type="file" id="importFile" style="display:none"/>
        <button class="btn ghost" id="importFull">Import</button>
      </div>
      <div style="margin-top:10px"><button class="btn ghost" id="clearStorage">Clear Storage</button></div>
    </div>
  </aside>
</div>

<footer style="text-align:center;margin-top:12px;color:var(--muted);font-size:13px">Demo only ‚Äî no real money. Tweak starting balance in the script.</footer>

<script>
/* ------------------------------
  RainClone ‚Äî Supercharged Single-file Demo
  - Surprise features included: SVG crash chart (history + zoom), smooth slot reels, strategy simulator.
  - Lots of bug fixes: element guards, animation cancelation, localStorage resilience.
  - All client-side. Modify START_BALANCE below.
-------------------------------*/

document.addEventListener('DOMContentLoaded', () => {
  const START_BALANCE = 3000;
  const STORAGE_KEY = 'rainclone_super_v1';

  const qs = s => document.querySelector(s);
  const qsa = s => Array.from(document.querySelectorAll(s));
  const $ = id => document.getElementById(id);

  // state
  let state = {
    balance: START_BALANCE,
    history: [], // {game, outcome, amt, time, win}
    wins: 0,
    losses: 0,
    leaders: [],
    provable: { seed: null, hash: null },
    achievements: {},
    crashHistory: [] // store multipliers of last rounds for SVG overlay
  };

  // load saved state safely
  function loadState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){
        const parsed = JSON.parse(raw);
        // validate fields to avoid malformed state errors
        if(typeof parsed === 'object'){
          state = Object.assign(state, parsed);
          // ensure arrays exist
          state.history = Array.isArray(state.history) ? state.history : [];
          state.crashHistory = Array.isArray(state.crashHistory) ? state.crashHistory : [];
          state.leaders = Array.isArray(state.leaders) ? state.leaders : [];
          state.achievements = state.achievements || {};
        }
      }
    } catch(e){
      console.warn('Failed to load state:', e);
      // fallback to defaults
      state = Object.assign({}, state);
    }
  }
  function saveState(){
    try {
      if(document.getElementById('persist') && document.getElementById('persist').checked){
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }
    } catch(e){
      console.warn('save failed', e);
    }
    renderHeader();
  }

  // UI updates
  function renderHeader(){
    const top = $('topBalance');
    if(top) top.innerText = (state.balance || 0).toFixed(2) + ' RC';
    const wallet = $('wallet');
    if(wallet) wallet.innerText = (state.balance || 0).toFixed(2) + ' RC';
    const stats = $('stats');
    if(stats) stats.innerText = `W:${state.wins} L:${state.losses}`;
    const prov = $('provHash');
    if(prov) prov.innerText = state.provable.hash || '‚Äî';
    renderHistoryPanels();
    renderLeaders();
    renderAchievements();
    drawAnalytics();
  }

  function pushRound(round){
    // round: {game, outcome, amt, time, win}
    state.history.unshift(round);
    if(state.history.length > 300) state.history.length = 300;
    if(round.win && round.amt > 0) state.leaders.unshift({ name: 'You', win: round.amt, time: round.time });
    // keep leaders trimmed
    state.leaders.sort((a,b)=>b.win-a.win);
    if(state.leaders.length > 50) state.leaders.length = 50;
    // track crash history multipliers (if round contains crashMult)
    if(round.game === 'Crash' && typeof round.crashMult === 'number'){
      state.crashHistory.unshift(round.crashMult);
      if(state.crashHistory.length > 50) state.crashHistory.length = 50;
    }
    saveState();
  }

  function renderHistoryPanels(){
    const leftHistory = $('leftHistory'); if(leftHistory) leftHistory.innerHTML = '';
    const ticker = $('leftHistory'); // reuse small area (keeps UI simple)
    (state.history.slice(0,20)).forEach(h => {
      const d = document.createElement('div'); d.style.padding='8px'; d.style.borderBottom='1px solid rgba(255,255,255,0.02)';
      d.innerHTML = `<div style="display:flex;justify-content:space-between"><div style="font-weight:700">${h.game}</div><div class="muted">${h.time}</div></div><div class="muted">${h.outcome} <strong style="float:right">${h.amt>0? '+'+h.amt.toFixed(2): h.amt.toFixed(2)}</strong></div>`;
      if(leftHistory) leftHistory.appendChild(d);
    });
  }

  function renderLeaders(){
    const el = $('leaders'); if(!el) return;
    el.innerHTML = '';
    if(!state.leaders.length){ el.innerHTML = '<div class="muted">No wins yet</div>'; return; }
    state.leaders.slice(0,6).forEach((l,i) => {
      const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.padding='6px 0';
      row.innerHTML = `<div>${i+1}. ${l.name}</div><div class="muted">${l.win.toFixed(2)}</div>`;
      el.appendChild(row);
    });
  }

  function renderAchievements(){
    const el = $('achievements'); if(!el) return; el.innerHTML = '';
    const known = state.achievements || {};
    const badges = [
      {k:'first_win', label:'First win'},
      {k:'3_wins', label:'3 wins'},
      {k:'10_wins', label:'10 wins'},
      {k:'big_jackpot', label:'Big jackpot (‚â•500)'}
    ];
    badges.forEach(b => {
      const div = document.createElement('div'); div.className = 'achievement'; div.style.display='flex'; div.style.justifyContent='space-between'; div.style.padding='6px'; div.style.borderRadius='8px'; div.style.background='rgba(255,255,255,0.02)';
      div.innerHTML = `<div>${b.label}</div><div style="opacity:${known[b.k]?1:0.35}">${known[b.k] ? '‚úÖ' : 'üîí'}</div>`;
      el.appendChild(div);
    });
  }

  // analytics small chart
  function drawAnalytics(){
    const canvas = $('analytics'); if(!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const rounds = state.history.slice(0,20);
    if(rounds.length === 0){
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,canvas.width, canvas.height);
      ctx.fillStyle = '#9aa0a6'; ctx.font = '12px sans-serif'; ctx.fillText('No rounds yet', 10, 20);
      $('winRate') && ($('winRate').innerText = '0%');
      return;
    }
    const max = Math.max(...rounds.map(r => Math.abs(r.amt) || 0), 1);
    const barW = (canvas.width - 20)/rounds.length;
    rounds.slice().reverse().forEach((r, i) => {
      const val = r.amt;
      const h = Math.min(canvas.height - 20, Math.abs(val)/max * (canvas.height - 30));
      const x = 10 + i * barW;
      const y = canvas.height - h - 10;
      ctx.fillStyle = (val >= 0) ? 'rgba(87,221,129,0.9)' : 'rgba(255,86,86,0.9)';
      ctx.fillRect(x, y, barW - 6, h);
    });
    const wins = state.history.filter(h => h.win).length;
    const rate = state.history.length ? Math.round((wins / state.history.length) * 100) : 0;
    $('winRate') && ($('winRate').innerText = rate + '%');
  }

  // achievements helper
  function award(key, label){
    if(!state.achievements[key]){
      state.achievements[key] = { label, time: new Date().toLocaleString() };
      pushRound({game:'System', outcome:'Achievement: '+label, amt:0, time: new Date().toLocaleTimeString(), win:true});
      saveState();
    }
  }

  // -------------------
  // Provably fair demo
  // -------------------
  async function newServerSeed(){
    const seed = Math.random().toString(36).slice(2) + Date.now().toString(36);
    state.provable.seed = seed;
    try {
      const hashBuf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(seed));
      state.provable.hash = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2,'0')).join('');
    } catch(e){
      // fallback simple hash if crypto fails (very unlikely)
      state.provable.hash = '0x' + Array.from(seed).reduce((s,c)=> s + c.charCodeAt(0).toString(16), '');
    }
    saveState(); renderHeader();
  }
  function revealServerSeed(){
    if(!state.provable.seed) return alert('No server seed yet. Click "New" to generate one.');
    alert('Server seed (demo):\n' + state.provable.seed + '\n\nHash: ' + (state.provable.hash || '‚Äî'));
  }

  // -------------------
  // Crash implementation (SVG chart + smooth)
  // -------------------
  let crashRunning = false;
  let crashRAF = null;
  // Simple function to create a determinisitic crash using a seed string
  function deterministicCrashFromSeed(seed){
    // map seed -> number between 1.00 and 30.00 using simple hash reduce
    let acc = 0;
    for(let i=0;i<seed.length;i++) acc = (acc * 31 + seed.charCodeAt(i)) % 1000000;
    const r = (acc % 100000) / 100000; // 0..0.99999
    const crash = 1 + Math.pow(r, -0.5); // heavier tail
    return Math.min(100, Math.round(crash * 100)/100);
  }

  function renderCrashView(){
    const main = $('mainGame');
    if(!main) return;
    main.innerHTML = `
      <h2>Crash ‚Äî Large</h2>
      <div class="muted">SVG history shown below; manual and auto cashout supported.</div>
      <div style="margin-top:12px">
        <svg id="crashSVG" class="crash-svg" viewBox="0 0 1000 240" preserveAspectRatio="none" style="width:100%;height:240px"></svg>
      </div>
      <div class="crash-controls">
        <div class="muted">Bet</div><input id="crashBet" type="number" value="150" style="width:120px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit">
        <div class="muted">Auto cashout</div><input id="crashAuto" type="number" value="2.00" step="0.01" style="width:110px;padding:8px;border-radius:8px">
        <button class="btn" id="startCrash">Place & Start</button>
        <button class="btn ghost" id="cashCrash">Cashout</button>
        <button class="btn ghost" id="zoomToggle">Zoom</button>
      </div>
      <div id="crashHint" class="muted" style="margin-top:10px">Status: idle</div>
    `;
    drawCrashSVG(); // initial render
    // event binding
    const startBtn = $('startCrash'); if(startBtn) startBtn.addEventListener('click', ()=> {
      const bet = parseFloat($('crashBet').value) || 0;
      const autoCash = parseFloat($('crashAuto').value) || null;
      startCrashRound(bet, autoCash);
    });
    const cashBtn = $('cashCrash'); if(cashBtn) cashBtn.addEventListener('click', manualCashout);
    const zoom = $('zoomToggle'); if(zoom) zoom.addEventListener('click', ()=> {
      // zoom toggles between full and zoomed view by changing viewBox scale
      const svg = $('crashSVG');
      if(!svg) return;
      const vb = svg.getAttribute('data-zoom') === '1';
      if(vb){
        svg.removeAttribute('viewBox');
        svg.setAttribute('data-zoom','0');
      } else {
        // zoom in to last half of view
        svg.setAttribute('viewBox','500 0 500 240');
        svg.setAttribute('data-zoom','1');
      }
    });
  }

  function drawCrashSVG(){
    const svg = $('crashSVG'); if(!svg) return;
    // clear
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    // background rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x','0'); rect.setAttribute('y','0'); rect.setAttribute('width','100%'); rect.setAttribute('height','100%');
    rect.setAttribute('fill','rgba(255,255,255,0.01)');
    svg.appendChild(rect);
    // draw baseline grid lines
    for(let i=0;i<5;i++){
      const y = 240 - (i*(240/5));
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1','0'); line.setAttribute('x2','1000'); line.setAttribute('y1',String(y)); line.setAttribute('y2',String(y));
      line.setAttribute('stroke','rgba(255,255,255,0.02)'); line.setAttribute('stroke-width','1');
      svg.appendChild(line);
    }
    // if crash history exists, plot polyline
    const history = state.crashHistory.slice(0,50).reverse();
    if(history.length){
      const maxMult = Math.max(...history, 10);
      const points = history.map((m,i)=>{
        const x = Math.round(i*(1000/(history.length-1||1)));
        const y = Math.round(240 - ( (Math.min(m, maxMult)/maxMult) * 220) - 10);
        return `${x},${y}`;
      }).join(' ');
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      poly.setAttribute('points', points);
      poly.setAttribute('fill','none');
      poly.setAttribute('stroke','url(#grad1)');
      poly.setAttribute('stroke-width','3');
      // gradient
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
      grad.setAttribute('id','grad1'); grad.setAttribute('x1','0%'); grad.setAttribute('x2','100%');
      const s1 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s1.setAttribute('offset','0%'); s1.setAttribute('stop-color','#46d5ff');
      const s2 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s2.setAttribute('offset','100%'); s2.setAttribute('stop-color','#7b61ff');
      grad.appendChild(s1); grad.appendChild(s2); defs.appendChild(grad); svg.appendChild(defs);
      svg.appendChild(poly);
      // add markers for last value
      const last = history[history.length-1];
      const lastX = Math.round( (history.length-1) * (1000/(history.length-1||1)));
      const lastY = Math.round(240 - ((Math.min(last,Math.max(...history,10)) / Math.max(...history,10)) * 220) - 10);
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', String(lastX)); circle.setAttribute('cy', String(lastY)); circle.setAttribute('r','6'); circle.setAttribute('fill','#46d5ff'); svg.appendChild(circle);
    } else {
      // no history: draw example faint curve
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,230 C200,120 400,90 600,50 800,30 1000,10');
      path.setAttribute('fill','none'); path.setAttribute('stroke','rgba(255,255,255,0.03)'); path.setAttribute('stroke-width','2');
      svg.appendChild(path);
    }
  }

  function startCrashRound(bet, autoCashout){
    if(crashRunning){ alert('Round already running'); return; }
    if(!bet || bet <= 0){ alert('Invalid bet'); return; }
    if(bet > state.balance){ alert('Insufficient funds'); return; }
    // commit bet
    state.balance -= bet; renderHeader();
    const seed = (state.provable.seed || Math.random().toString(36).slice(2)) + Date.now().toString(36);
    // deterministic-ish crash
    const crashAt = deterministicCrashFromSeed(seed);
    let mult = 1.0;
    crashRunning = true;
    $('crashHint') && ($('crashHint').innerText = 'Running...');
    let last = performance.now();
    function animate(now){
      const dt = (now - last)/1000; last = now;
      // growth model: exponential-ish
      mult += dt * (0.8 + Math.log(mult + 1) * 0.5);
      // check auto
      if(autoCashout && mult >= autoCashout){
        // win
        const profit = Math.round((autoCashout - 1) * bet * 100) / 100;
        state.balance += bet + profit;
        addRoundAndFinish('Crash', `Auto cashout @${autoCashout.toFixed(2)}x`, profit, true, crashAt);
        return;
      }
      // crash condition
      if(mult >= crashAt){
        // crash: lose bet
        addRoundAndFinish('Crash', `Crashed @${crashAt.toFixed(2)}x`, -bet, false, crashAt);
        return;
      }
      // update displayed multiplier
      $('crashHint') && ($('crashHint').innerText = `Running ‚Äî ${mult.toFixed(2)}x`);
      crashRAF = requestAnimationFrame(animate);
    }
    crashRAF = requestAnimationFrame(animate);
  }

  function manualCashout(){
    if(!crashRunning){ alert('No active crash round'); return; }
    // we don't have the current 'bet' and 'mult' in this scope; store them via closure? To avoid complexity,
    // we'll provide a simplified manual cashout approach by scanning the last active round from history: but
    // since we need the current multiplier, we will store current crashState. Implement crashState above.
    if(!window.__crashState || !window.__crashState.running){ alert('No active crash'); return; }
    const cs = window.__crashState;
    const profit = Math.round((cs.mult - 1) * cs.bet * 100) / 100;
    state.balance += cs.bet + profit;
    addRoundAndFinish('Crash', `Manual cashout @${cs.mult.toFixed(2)}x`, profit, true, cs.crashAt);
  }

  function addRoundAndFinish(game, outcome, amt, win, crashAt){
    crashRunning = false;
    if(crashRAF) { cancelAnimationFrame(crashRAF); crashRAF = null; }
    // push round with crashAt if relevant
    const entry = { game, outcome, amt: amt, time: new Date().toLocaleTimeString(), win: !!win };
    if(typeof crashAt === 'number') entry.crashMult = crashAt;
    state.history.unshift(entry);
    if(entry.win) state.wins++;
    else if(game !== 'System') state.losses++;
    if(entry.win && amt >= 500) award('big_jackpot','Big Jackpot');
    // push history & crash history
    if(typeof crashAt === 'number') state.crashHistory.unshift(crashAt);
    if(state.crashHistory.length > 50) state.crashHistory.length = 50;
    saveState();
    // update UI
    $('crashHint') && ($('crashHint').innerText = `${outcome} (${amt >=0 ? '+'+amt.toFixed(2) : amt.toFixed(2)} RC)`);
    drawCrashSVG();
    renderHeader();
  }

  // To support manual cashout in a robust way, create global crashState to be referenced by manual cashout.
  window.__crashState = { running:false, mult:1.0, bet:0, crashAt:0 };

  // Improved startCrashRound storing crashState
  function startCrashRound(bet, autoCashout){
    if(window.__crashState.running){ alert('Round already running'); return; }
    if(!bet || bet <= 0){ alert('Invalid bet'); return; }
    if(bet > state.balance){ alert('Insufficient funds'); return; }
    state.balance -= bet; renderHeader();
    const seed = (state.provable.seed || Math.random().toString(36).slice(2)) + Date.now().toString(36);
    const crashAt = deterministicCrashFromSeed(seed);
    window.__crashState = { running:true, mult:1.0, bet:bet, crashAt:crashAt, raf:null };
    $('crashHint') && ($('crashHint').innerText = 'Running...');
    let last = performance.now();
    function loop(now){
      const cs = window.__crashState;
      const dt = (now - last)/1000; last = now;
      cs.mult += dt * (0.8 + Math.log(cs.mult + 1) * 0.6);
      // auto cashout
      if(autoCashout && cs.mult >= autoCashout){
        const profit = Math.round((autoCashout - 1) * bet * 100) / 100;
        state.balance += bet + profit;
        pushRound({game:'Crash', outcome:`Auto cashout @${autoCashout.toFixed(2)}x`, amt:profit, time:new Date().toLocaleTimeString(), win:true, crashMult:crashAt});
        cs.running = false;
        cs.raf && cancelAnimationFrame(cs.raf);
        window.__crashState = { running:false, mult:1.0, bet:0, crashAt:0 };
        saveState(); renderHeader(); drawCrashSVG(); $('crashHint') && ($('crashHint').innerText = `Auto-cashed @${autoCashout.toFixed(2)}x (+${profit} RC)`);
        return;
      }
      if(cs.mult >= cs.crashAt){
        // crashed
        pushRound({game:'Crash', outcome:`Crashed @${cs.crashAt.toFixed(2)}x`, amt:-bet, time:new Date().toLocaleTimeString(), win:false, crashMult: cs.crashAt});
        cs.running = false;
        cs.raf && cancelAnimationFrame(cs.raf);
        window.__crashState = { running:false, mult:1.0, bet:0, crashAt:0 };
        saveState(); renderHeader(); drawCrashSVG(); $('crashHint') && ($('crashHint').innerText = `Crashed @${cs.crashAt.toFixed(2)}x ‚Äî lost ${bet} RC`);
        return;
      }
      // update hint
      $('crashHint') && ($('crashHint').innerText = `Running ‚Äî ${cs.mult.toFixed(2)}x`);
      cs.raf = requestAnimationFrame(loop);
    }
    window.__crashState.raf = requestAnimationFrame(loop);
  }

  // -------------------
  // Slots: smooth physics-style reels
  // -------------------
  const slotSymbols = ['üçí','üçã','üîî','‚≠ê','7Ô∏è‚É£'];
  function renderSlots(){
    const main = $('mainGame');
    if(!main) return;
    main.innerHTML = `
      <h2>Slots ‚Äî Smooth Reels</h2>
      <div class="muted">Spin and watch reels stop one after another. Matching results pay out.</div>
      <div class="slots-row">
        <div class="reel" id="r1">${slotSymbols[0]}</div>
        <div class="reel" id="r2">${slotSymbols[1]}</div>
        <div class="reel" id="r3">${slotSymbols[2]}</div>
      </div>
      <div style="display:flex;align-items:center;gap:12px;margin-top:16px">
        <div class="muted">Bet</div><input id="slotsBet" type="number" value="150" style="width:120px;padding:8px;border-radius:8px">
        <button class="btn" id="spinBtn">Spin</button>
        <div id="slotsMsg" class="muted">Try to match 3 ‚Äî big payout for 7Ô∏è‚É£</div>
      </div>
    `;
    const r1 = $('r1'), r2 = $('r2'), r3 = $('r3');
    const spinBtn = $('spinBtn');
    let spinning = false;
    function stopReel(el, symbol){
      el.classList.remove('spin');
      el.innerText = symbol;
    }
    async function spin(){
      if(spinning) return;
      const bet = parseFloat($('slotsBet').value) || 0;
      if(!bet || bet > state.balance){ alert('Invalid bet or insufficient funds'); return; }
      spinning = true;
      state.balance -= bet; saveState(); renderHeader();
      // add quick flicker animation
      [r1,r2,r3].forEach(el => el.classList.add('spin'));
      // create target symbols
      const target1 = slotSymbols[Math.floor(Math.random()*slotSymbols.length)];
      const target2 = slotSymbols[Math.floor(Math.random()*slotSymbols.length)];
      const target3 = slotSymbols[Math.floor(Math.random()*slotSymbols.length)];
      // stop delays staggered for satisfying feel
      await new Promise(r => setTimeout(r, 220)); stopReel(r1, target1);
      await new Promise(r => setTimeout(r, 160)); stopReel(r2, target2);
      await new Promise(r => setTimeout(r, 180)); stopReel(r3, target3);
      // evaluate
      let profit = 0;
      if(target1 === target2 && target2 === target3){
        profit = (target1 === '7Ô∏è‚É£') ? bet * 50 : bet * 10;
      } else if (target1 === target2 || target2 === target3 || target1 === target3){
        profit = bet * 2;
      }
      if(profit > 0){
        state.balance += bet + profit;
        addRoundAndFinish('Slots', `Win ${profit.toFixed(2)} RC`, profit, true);
        $('slotsMsg').innerText = `Win +${profit.toFixed(2)} RC`;
      } else {
        addRoundAndFinish('Slots', `Lose ${bet.toFixed(2)} RC`, -bet, false);
        $('slotsMsg').innerText = `No match ‚Äî lost ${bet.toFixed(2)} RC`;
      }
      spinning = false;
      saveState(); renderHeader();
    }
    spinBtn && spinBtn.addEventListener('click', spin);
  }

  // -------------------
  // Dice
  // -------------------
  function renderDice(){
    const main = $('mainGame');
    if(!main) return;
    main.innerHTML = `
      <h2>Dice ‚Äî Large</h2>
      <div class="muted">Pick a target (4-6). Roll 1-6 to win.</div>
      <div style="display:flex;gap:24px;align-items:center;margin-top:16px">
        <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
          <div class="muted">Pick</div>
          <select id="dicePick" style="padding:8px;border-radius:8px"><option value="4">‚â• 4</option><option value="5">‚â• 5</option><option value="6">= 6</option></select>
          <div class="muted">Bet</div><input id="diceBet" type="number" value="150" style="width:120px;padding:8px;border-radius:8px">
          <button class="btn" id="diceRoll">Roll</button>
        </div>
        <div style="text-align:center">
          <div class="muted">Result</div>
          <div id="diceFace" style="font-size:120px;padding:18px;margin-top:8px;background:rgba(255,255,255,0.02);border-radius:14px">‚Äî</div>
          <div id="diceMsg" class="muted" style="margin-top:8px">Roll to play</div>
        </div>
      </div>
    `;
    $('diceRoll').addEventListener('click', ()=>{
      const pick = parseInt($('dicePick').value,10);
      const bet = parseFloat($('diceBet').value) || 0;
      if(!bet || bet > state.balance){ alert('Invalid bet or insufficient funds'); return; }
      state.balance -= bet; saveState(); renderHeader();
      const roll = Math.floor(Math.random()*6)+1;
      let win=false, profit=0;
      if(pick === 6){
        if(roll === 6){ win=true; profit = bet * 5; }
      } else {
        if(roll >= pick){ win=true; profit = Math.round((bet * (6/(6-(pick-1)) - 1)) * 100) / 100; }
      }
      $('diceFace').innerText = roll;
      if(win){ state.balance += bet + profit; addRoundAndFinish('Dice', `Rolled ${roll} ‚Äî WIN`, profit, true); $('diceMsg').innerText = `WIN +${profit.toFixed(2)} RC`; } else { addRoundAndFinish('Dice', `Rolled ${roll} ‚Äî LOSE`, -bet, false); $('diceMsg').innerText = `LOSE -${bet.toFixed(2)} RC`; }
    });
  }

  // -------------------
  // Mines
  // -------------------
  function renderMinesView(){
    const main = $('mainGame');
    if(!main) return;
    main.innerHTML = `
      <h2>Mines ‚Äî Focused</h2>
      <div class="muted">Open tiles. Hit a bomb = lose. Cashout anytime to collect reward.</div>
      <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
        <div><div class="muted">Bombs</div><select id="bombCount" style="padding:8px;border-radius:8px"><option value="3">3</option><option value="5" selected>5</option><option value="8">8</option></select></div>
        <div><div class="muted">Bet</div><input id="minesBet" type="number" value="150" style="width:120px;padding:8px;border-radius:8px"></div>
        <div style="margin-left:auto"><button class="btn" id="startMines">Start</button><button class="btn ghost" id="cashMines">Cashout</button></div>
      </div>
      <div class="mines-grid" id="minesGrid" style="margin-top:12px"></div>
      <div id="minesMsg" class="muted" style="margin-top:8px"></div>
    `;
    const grid = $('minesGrid'); if(!grid) return;
    function initGrid(){
      grid.innerHTML = '';
      for(let i=0;i<48;i++){
        const cell = document.createElement('div');
        cell.className = 'mine-cell';
        cell.dataset.i = i;
        cell.innerText = '?';
        grid.appendChild(cell);
      }
    }
    initGrid();
    let bombs = new Set(), opened = new Set(), currentBet = 0, running=false;
    function start(){
      const bet = parseFloat($('minesBet').value) || 0;
      if(!bet || bet > state.balance){ alert('Invalid bet or insufficient funds'); return; }
      const count = parseInt($('bombCount').value,10);
      state.balance -= bet; saveState(); renderHeader();
      currentBet = bet; running = true; opened.clear(); bombs.clear();
      while(bombs.size < count) bombs.add(Math.floor(Math.random()*48));
      grid.querySelectorAll('.mine-cell').forEach(c => { c.classList.remove('mine-open'); c.innerText = '?'; });
      $('minesMsg').innerText = `Started ‚Äî open tiles carefully.`;
      pushRound({game:'Mines', outcome:'Started', amt:-bet, time:new Date().toLocaleTimeString(), win:false});
    }
    function openCell(idx, el){
      if(!running) return;
      if(opened.has(idx)) return;
      opened.add(idx);
      if(bombs.has(idx)){
        el.classList.add('mine-open'); el.innerText = 'üí£';
        running = false;
        pushRound({game:'Mines', outcome:'Hit bomb', amt:-currentBet, time:new Date().toLocaleTimeString(), win:false});
        $('minesMsg').innerText = 'Boom ‚Äî hit a bomb.';
        renderHeader(); saveState();
      } else {
        el.classList.add('mine-open'); el.innerText = '‚Ä¢';
        const mul = 1 + (opened.size * 0.12);
        $('minesMsg').innerText = `Safe ‚Äî multiplier x${mul.toFixed(2)} ‚Äî open more or cashout.`;
      }
    }
    function cashout(){
      if(!running){ alert('No active mines round'); return; }
      const mul = 1 + (opened.size * 0.12);
      const profit = Math.round((currentBet * (mul - 1)) * 100) / 100;
      state.balance += currentBet + profit;
      pushRound({game:'Mines', outcome:`Cashed x${mul.toFixed(2)}`, amt:profit, time:new Date().toLocaleTimeString(), win:true});
      running = false;
      $('minesMsg').innerText = `Cashed out +${profit.toFixed(2)} RC`;
      renderHeader(); saveState();
    }
    grid.addEventListener('click', (e) => {
      const cell = e.target.closest('.mine-cell');
      if(!cell) return;
      const idx = parseInt(cell.dataset.i,10);
      openCell(idx, cell);
    });
    $('startMines').addEventListener('click', start);
    $('cashMines').addEventListener('click', cashout);
  }

  // -------------------
  // Strategy simulator
  // -------------------
  function renderSimulator(){
    const main = $('mainGame');
    if(!main) return;
    main.innerHTML = `
      <h2>Strategy Simulator</h2>
      <div class="muted">Backtest Martingale or Fixed strategies on a simulated Crash RNG.</div>
      <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
        <div class="muted">Mode</div><select id="simMode" style="padding:8px;border-radius:8px"><option value="martingale">Martingale</option><option value="fixed">Fixed</option></select>
        <div class="muted">Start bet</div><input id="simStart" type="number" value="50" style="width:120px;padding:8px;border-radius:8px">
        <div class="muted">Rounds</div><input id="simRounds" type="number" value="200" style="width:120px;padding:8px;border-radius:8px">
        <button class="btn" id="runSim">Run</button>
      </div>
      <canvas id="simCanvasMain" width="900" height="220" style="width:100%;height:220px;background:rgba(255,255,255,0.01);border-radius:8px;margin-top:12px"></canvas>
      <div id="simResult" class="muted" style="margin-top:8px"></div>
    `;
    $('runSim').addEventListener('click', runSimulation);
  }

  function runSimulation(){
    const mode = $('simMode').value;
    const startBet = Math.max(1, parseFloat($('simStart').value) || 50);
    const rounds = Math.max(1, parseInt($('simRounds').value,10) || 200);
    let balance = 10000; // simulator bankroll
    let bet = startBet;
    const history = [];
    for(let i=0;i<rounds;i++){
      // simulate crash
      const crash = deterministicCrashFromSeed((Math.random().toString(36)+Date.now().toString(36)).slice(0,12));
      const target = 2.0; // we assume we're cashing at 2x for the strategy
      if(crash >= target){
        // win
        const profit = Math.round((target - 1) * bet * 100) / 100;
        balance += profit;
        history.push(balance);
        if(mode === 'martingale') bet = startBet;
        else bet = startBet;
      } else {
        // lose
        balance -= bet;
        history.push(balance);
        if(mode === 'martingale') bet = Math.min(balance, bet*2);
        else bet = startBet;
      }
      if(balance <= 0) break;
    }
    // draw history
    const canvas = $('simCanvasMain'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const max = Math.max(...history, 1); const min = Math.min(...history,0);
    history.forEach((v,i) => {
      const x = i * (canvas.width / (history.length||1));
      const y = canvas.height - ((v - min) / (max - min || 1)) * (canvas.height - 20) - 10;
      ctx.fillStyle = i === history.length-1 ? '#46d5ff' : 'rgba(70,213,255,0.6)';
      ctx.fillRect(x, y, Math.max(2, canvas.width / (history.length||1) - 1), 4);
    });
    $('simResult').innerText = `End balance: ${history.length? history[history.length-1].toFixed(2) : balance.toFixed(2)}  (start ${startBet})`;
  }

  // Helper to open a game view and render UI
  function openGame(name){
    const home = $('homeView'), game = $('gameView');
    if(!home || !game) return;
    home.style.display = name === 'home' ? 'block' : 'none';
    game.style.display = name === 'home' ? 'none' : 'flex';
    $('roundLabel') && ($('roundLabel').innerText = name.charAt(0).toUpperCase() + name.slice(1));
    // clear main
    const main = $('mainGame'); if(!main) return;
    main.innerHTML = '';
    if(name === 'home'){
      // nothing
    } else if(name === 'crash'){
      renderCrashView();
      // ensure crash controls bound
      const start = $('startCrash'); start && start.addEventListener('click', ()=> {
        const bet = parseFloat($('crashBet').value) || 0;
        const auto = parseFloat($('crashAuto').value) || null;
        startCrashRound(bet, auto);
      });
      const cashB = $('cashCrash'); cashB && cashB.addEventListener('click', ()=> {
        // manual cashout uses global crash state
        if(window.__crashState && window.__crashState.running){
          const cs = window.__crashState;
          const profit = Math.round((cs.mult - 1) * cs.bet * 100) / 100;
          state.balance += cs.bet + profit;
          pushRound({game:'Crash', outcome:`Manual cashout @${cs.mult.toFixed(2)}x`, amt:profit, time:new Date().toLocaleTimeString(), win:true, crashMult: cs.crashAt});
          // stop
          cs.running = false;
          if(cs.raf) cancelAnimationFrame(cs.raf);
          window.__crashState = { running:false, mult:1, bet:0, crashAt:0 };
          saveState(); renderHeader(); drawCrashSVG(); $('crashHint') && ($('crashHint').innerText = `Cashed out @${cs.mult.toFixed(2)}x (+${profit.toFixed(2)} RC)`);
        } else alert('No running crash round.');
      });
    } else if(name === 'slots'){
      renderSlots();
    } else if(name === 'dice'){
      renderDice();
    } else if(name === 'mines'){
      renderMinesView();
    } else if(name === 'sim'){
      renderSimulator();
    }
  }

  // Basic helpers to add rounds and update achievements
  function addRoundEntry(game, outcome, amt, win, crashMult){
    const entry = { game, outcome, amt, time: new Date().toLocaleTimeString(), win };
    if(typeof crashMult === 'number') entry.crashMult = crashMult;
    state.history.unshift(entry);
    if(state.history.length > 300) state.history.length = 300;
    if(win) state.wins++; else if(game !== 'System') state.losses++;
    if(win && amt >= 500) award('big_jackpot','Big jackpot');
    if(state.wins >= 1) award('first_win','First win');
    if(state.wins >= 3) award('3_wins','3 wins');
    if(state.wins >= 10) award('10_wins','10 wins');
    saveState();
  }

  function addRound(r){
    // wrapper preserving interface used earlier
    addRoundEntry(r.game, r.outcome, r.amt, r.win, r.crashMult);
  }

  // -----------------
  // Bind UI top-level
  // -----------------
  function bindUI(){
    // left menu
    qsa('.game-btn').forEach(btn => btn.addEventListener('click', e => {
      qsa('.game-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const g = btn.dataset.game;
      openGame(g);
    }));

    // home card opens
    qsa('.card[data-open]').forEach(card => card.addEventListener('click', e => {
      const g = card.dataset.open;
      const match = qsa(`.game-btn[data-game="${g}"]`)[0];
      qsa('.game-btn').forEach(b => b.classList.remove('active'));
      match && match.classList.add('active');
      openGame(g);
    }));

    // quick add
    $('addBtn').addEventListener('click', ()=> {
      const v = parseFloat($('quickAdd').value) || 0;
      state.balance += v;
      addRound({game:'System', outcome:'Added funds', amt:v, time:new Date().toLocaleTimeString(), win:true});
      saveState(); renderHeader();
    });

    // UI scale slider
    const uiScale = $('uiScale');
    uiScale && uiScale.addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--ui-scale', e.target.value);
    });

    // provable
    $('newSeed').addEventListener('click', newServerSeed);
    $('revealSeed').addEventListener('click', revealServerSeed);

    // export / import
    $('exportFull').addEventListener('click', ()=> {
      const blob = new Blob([JSON.stringify(state, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'rainclone_state.json'; a.click(); URL.revokeObjectURL(url);
    });
    $('importFull').addEventListener('click', ()=> $('importFile').click());
    $('importFile').addEventListener('change', (e)=> {
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const fr = new FileReader();
      fr.onload = ev => {
        try {
          const obj = JSON.parse(ev.target.result);
          Object.assign(state, obj);
          saveState(); renderHeader();
          alert('Imported state (demo)');
        } catch(err){ alert('Invalid file'); }
      };
      fr.readAsText(f);
    });

    // export & import header
    $('exportBtn').addEventListener('click', ()=> $('exportFull').click());
    $('importBtn').addEventListener('click', ()=> $('importFull').click());

    // clear storage
    $('clearStorage').addEventListener('click', ()=> { if(confirm('Clear local storage and reset demo?')){ localStorage.removeItem(STORAGE_KEY); location.reload(); }});

    // strategy simulator run (also bound in its rendering)
    $('runSim') && $('runSim').addEventListener('click', runSimulation);

    // keyboard shortcuts - place / cash operate as opening the focused view and triggering place/cash buttons
    window.addEventListener('keydown', (ev) => {
      if(ev.code === 'Space'){ ev.preventDefault(); // place -> open focused view
        const active = qsa('.game-btn').find(b => b.classList.contains('active'));
        if(active){
          // open focused game to ensure place control available
          openGame(active.dataset.game);
          // click placeBtn if exists
          const place = $('placeBtn');
          place && place.click();
        }
      } else if(ev.key.toLowerCase() === 'c'){
        const cash = $('cashBtn'); cash && cash.click();
      } else if(ev.key >= '1' && ev.key <= '6'){
        // quick switches for first several games (1-home,2-crash,3-dice,4-mines,5-slots,6-sim)
        const map = { '1':'home','2':'crash','3':'dice','4':'mines','5':'slots','6':'sim' };
        const target = map[ev.key];
        if(target){
          const match = qsa(`.game-btn[data-game="${target}"]`)[0];
          if(match){ qsa('.game-btn').forEach(b=>b.classList.remove('active')); match.classList.add('active'); openGame(target); }
        }
      }
    });

    // side place/cash binds
    $('placeBtn') && $('placeBtn').addEventListener('click', ()=> {
      // opens focused view of active game and focuses control (helps users)
      const active = qsa('.game-btn').find(b => b.classList.contains('active'));
      if(active) openGame(active.dataset.game);
    });
    $('cashBtn') && $('cashBtn').addEventListener('click', ()=> {
      // attempt to click the first cash-like button present
      const candidates = Array.from(document.querySelectorAll('button')).filter(b => /cash|cashout/i.test(b.id || b.innerText));
      if(candidates.length) candidates[0].click(); else alert('No cashout available in the current view.');
    });

    // UI adjustments: run simulator binding if element exists
    if($('runSim')) $('runSim').addEventListener('click', runSimulation);
  }

  // start
  loadState();
  renderHeader();
  bindUI();
  // open home by default
  openGame('home');

  // ensure provable exists
  if(!state.provable.seed) newServerSeed();

  // small helpers to expose some functions for easier debugging/testing in console (optional)
  window.RainClone = {
    state, saveState, loadState, openGame, newServerSeed, revealServerSeed
  };

  // initial draw for crash (empty)
  drawCrashSVG();

  // small fix: ensure elements that may not exist in some views are guarded before adding listeners
  // e.g., sim run button may be created later; we check its presence before binding.

  // ensure analytics refresh
  setInterval(() => {
    renderHeader();
  }, 800);

}); // domcontentloaded
</script>
</body>
</html>
